# 第六章 函数

函数是一个命了名的代码块，我们通过函数来调用相应的代码。函数可以进行重载，这就意味着一个函数名能对应着多个函数。

## 函数基础

**函数定义**：

包括返回类型、函数名字和0个或者多个**形参**（parameter）组成的列表和函数体。其中形参放在（）中，使用`,`隔开。

**调用运算符**：

调用运算符的形式是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针。我们通过调用运算符，来调用函数，在括号中放入实参。

- 圆括号内是用逗号隔开的**实参**（argument）列表。
- 函数调用过程：
  - 1.主调函数（calling function）的执行被中断。
  - 2.被调函数（called function）开始执行。
- 从作用效果上来说，函数的调用，无非就是，初始化形参列表之后，将代码块移植到调用函数这儿，执行代码块。但是本质上，这涉及函数栈帧的开辟与释放。函数的使用，能极大的简化代码编写的臃肿程度。

**形参和实参**：

形参和实参的**个数**和**类型**必须匹配上。实参是形参的初始值。形参列表通常使用`,`隔开，其中每个形参都是一个带有声明符的声明。即使两个形参的类型一样，也必须把两个形参的类型都写出来。

需要注意是，函数外部的全局变量不因该和函数的形参名字一样，不然会出现覆盖的现象。当你使用全局变量的时候，实质上使用的本地的形参变量。

**返回类型**： 

`void`表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。

**名字**：

名字的作用于是程序文本的一部分，名字在其中可见。

### 局部对象

**生命周期**：对象的生命周期是程序执行过程中该对象存在的一段时间。

**局部变量**（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是**隐藏**的。

**自动对象**：只存在于块执行期间的对象。当块的执行结束后，它的值就变成**未定义**的了。

**局部静态对象**： `static`类型的局部变量，生命周期贯穿函数调用前后。虽然是局部变量，但是它并不会随着函数调用结束就被销毁，而是一直保留，直到随程序一起被销毁。**静态变量在程序的生命周期内只会被初始化一次**

```cpp
size_t cout_calls()
{
	static size_t ctr = 0;
	return ++ctr;
}
int main()
{
	/*int num=fac(10);
	cout << "num = " << num << endl;
	fac(-1);*/
	//interactive_fact();
	for (int i = 0; i < 10; i++) {
		cout << cout_calls() << " ";
	}
}
```



### 函数声明

**函数声明**：函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代。函数声明主要用于描述函数的接口，也称**函数原型**。

因为函数的声明不包含函数体，因此函数的声明也就无需形参的名字，**事实上，在函数的声明中通常省略形参的名字。**但是写上形参名能帮助使用者更好的理解函数的声明。



**在头文件中进行函数声明**：建议变量在头文件中声明；在源文件中定义。对于函数也是如此，函数也应该在头文件中沈明，在源文件中定义。**定义函数的源文件应该把含有函数声明的头文件包含进来，以方便编译器检查函数声明和定义是否匹配。**



**分离编译**： `CC a.cc b.cc`直接编译生成可执行文件；`CC -c a.cc b.cc`编译生成对象代码`a.o b.o`； `CC a.o b.o`编译生成可执行文件。



**完整流程**

假设我们有一个文件 `file.h`，其中包含函数的声明：

```cpp
// file.h

#ifndef FILE_H
#define FILE_H

void printMessage();

#endif
```

接下来，在一个独立的文件 `file.cpp` 中实现该函数的定义：

```cpp
// file.cpp

#include <iostream>
#include "file.h"

void printMessage()
{
    std::cout << "Hello, World!" << std::endl;
}
```

现在，我们希望在 `main.cpp` 文件中调用 `printMessage()` 函数：

```cpp
// main.cpp

#include "file.h"

int main()
{
    printMessage();
    return 0;
}
```

使用以下命令来编译这些文件：

```
g++ -o myprogram main.cpp file.cpp
```

其中，`-o` 选项指定生成的可执行文件的名称（此处为 `myprogram`）。`main.cpp` 和 `file.cpp` 是要编译的源代码文件。

> 因为在 `main.cpp` 中已经包含了 `file.h` 头文件。编译器会根据 `main.cpp` 中的包含语句查找所需的头文件，并在编译过程中将其包含进来。所以无需显式地将头文件 `file.h` 包含在编译命令中。但是需要在`main.cpp`中引入头文件。
>
> 头文件的主要作用是提供函数声明、类声明、常量定义等信息，以便编译器在编译时知道如何正确处理这些标识符。当你在 `main.cpp` 中包含了 `file.h` 头文件时，编译器会在编译 `main.cpp` 时查看头文件的内容。因此，在编译期间，编译器将看到 `file.h` 中的函数声明，并知道如何正确地使用 `printMessage()` 函数。

执行该命令后，如果没有错误，将会生成一个名为 `myprogram` 的可执行文件。现在，可以运行该可执行文件来查看结果：

```
./myprogram
```

输出应该是：

```
Hello, World!
```

在编译过程中，编译器将首先处理 `main.cpp` 文件并查找所需的函数声明。由于我们在 `main.cpp` 中包含了 `file.h` 头文件，编译器将在 `file.h` 文件中找到 `printMessage()` 函数的声明。然后，编译器会继续处理 `file.cpp` 文件，找到 `printMessage()` 函数的定义，并将其与 `main.cpp` 中的调用连接起来。最终，链接器将所有必需的代码组合在一起生成可执行文件。

分文件编译的主要优点是可以将代码分割成逻辑上相关的模块，提高代码的可读性和可维护性。同时，这种方式也支持代码的重用，可以在多个文件中共享函数和类型定义。

需要注意的是，编译多个文件时，需要确保头文件包含了相应的函数声明，并在编译命令中同时包含所有的源代码文件。另外，为了避免重复定义，通常在头文件中使用预处理器指令（例如 `#ifndef`、`#define` 和 `#endif`）来包裹函数声明，以防止多次包含同一个头文件。



## 参数传递

形参初始化的机理和变量初始化一样，主要分为两类：

- **引用传递**（passed by reference）：又称传引用调用（called by reference），指**形参是引用类型**，引用形参是它对应的实参的别名。
- **值传递**（passed by value）：又称传值调用（called by value），指实参的值是通过**拷贝**传递给形参。

### 传值参数

- 当初始化一个非引用类型的变量时，初始值被拷贝给变量。
- 函数对形参做的所有操作都不会影响实参。
- **指针形参**：常用在C中，`C++`建议使用引用类型的形参代替指针。能有效增强代码的可读性

### 传引用参数

- 通过使用引用形参，允许函数改变一个或多个实参的值。

- 引用形参直接关联到绑定的对象，而非对象的副本。

- 使用引用形参可以用于**返回额外的信息**。

  `void swap(int &v1, int &v2)`

>经常用引用形参来避免不必要的拷贝。尤其是使用类类型的参数，使用引用能极大的节省开销。如果函数无需改用引用形参的值，最好将其声明为常量引用。
>
>对于C++来说，一次只能返回一个值，但是有些时候，我们可能需要返回多个值，这个时候，我们就可以利用引用参数来帮助我们解决这个问题，增设函数参数，来跟踪变化。

### const形参和实参

形参的顶层`const`被忽略。`void func(const int i);`调用时既可以传入`const int`也可以传入`int`，所以它和`void func(int i);`声明没有本质的区别，不能作为函数重构的依据。

**我们可以使用非常量初始化一个底层`const`对象，但是反过来不行**。例如

```cpp
int i=0;
const int j=i;//这是可行的，可以使用非常量初始化一个底层const对象

const int &r=i;
int &r3=r;//这是不可行的，应为不能使用底层const去初始化一个非常化的变量
```



**尽量使用常量引用**

这样能限制函数在调用过程中，对引用的修改，减少了误操作的可能。而且使用引用而非常量引用会很大的限制函数所能接受的实参类型。（因为使用const变量来初始非const对象是不可以的），例如

```cpp
string::size_type find_char(string &s,char c,
						 string::size_type &occurs);
						 
//当传入字符串常量的时候，会报错
find_char("hello world",'o',ctr);
//所以需要设计为const string& s作为参数变量
```



### 数组形参

数组不能拷贝，因此我们不能使用值传递的时候，使用数组。但是数组会被转换为指针，因此当我们传递数组参数的时候，实际上传的是数组的首地址。

一般而言，我们采用下面这几种参数的书写方法

```cpp
void test(const int* arr);
void test(const int[] arr);
```

但是数组的大小一般是不确定的，为此，我们有以下几种办法

1. 使用传递首尾指针的方法

   ```cpp
   void print(const int *beg,const int *end){
   
   }
   int j[2]={0,1};
   print(begin(j),end(j));
   ```

2. 增加一个显示传递数组大小的形参

   ```cpp
   void print(const int ia[],size_t size){
   
   }
   int j[2]={0,1};
   print(j,end(j)-begin(j));
   ```



**数组形参和const**

```cpp
void print(int (&arr) [10]){

}
```

这里需要注意的是，需要加上括号，应为数组的优先级高，所以需要先确认它是引用，然后在确认它引用对象是一个数组



**多维数组形参**

```
int (*matrix) [10]//martix是一个指针，指向的对象是拥有10个元素的数组
等价于
int arr[][10]
但是区别于
int *matrix[10]   //这个matrix是一个数组，数组存放的元素是指针
```



### main处理命令行选项

有些时候，也需要给main函数传递实参，例如使用命令行执行`.exe`文件的时候，这个时候main函数的参数应该写成`int main(int argc, char *argv[]){...}`

第一个形参代表参数的个数；第二个形参是参数C风格字符串数组。

例如当执行下main这一条命令时：

`prog -d -o ofile data0`,argc=5,argv={"prog","-d","-o","ofile","data0","0"},0表示结尾。其中第一个参数是可执行文件的名称，因此真正的形参开始于argv[1]，结束于argv[argc-1]

### 可变形参

`initializer_list`提供的操作（`C++11`）：

| 操作 | 解释 |
|-----|-----|
| `initializer_list<T> lst;` | 默认初始化；`T`类型元素的空列表 |
| `initializer_list<T> lst{a,b,c...};` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const`。 |
| `lst2(lst)` | 拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 |
| `lst2 = lst` | 同上 |
| `lst.size()` | 列表中的元素数量 |
| `lst.begin()` | 返回指向`lst`中首元素的指针 |
| `lst.end()` | 返回指向`lst`中微元素下一位置的指针 |

`initializer_list`使用demo：

```cpp
void err_msg(ErrCode e, initializer_list<string> il){
    cout << e.msg << endl;
    for (auto bed = il.begin(); beg != il.end(); ++ beg)
        cout << *beg << " ";
    cout << endl;
}

err_msg(ErrCode(0), {"functionX", "okay});
```

- 所有实参类型相同，可以使用 `initializer_list`的标准库类型。
- 实参类型不同，可以使用`可变参数模板`。

## 返回类型和return语句

### 无返回值函数

没有返回值的 `return`语句只能用在返回类型是 `void`的函数中，返回 `void`的函数不要求非得有 `return`语句。

### 有返回值函数

`return`语句的返回值的类型必须和函数的返回类型相同，或者能够**隐式地**转换成函数的返回类型。

值的返回：返回的值用于初始化调用点的一个**临时量**，该临时量就是函数调用的结果。

**不要返回局部对象的引用或指针**

例如：

```cpp
const string &manip()
{
    string ret;
    if(!ret.empyt()){
		return ret;//这里ret是临时变量，因此不能返回
    }
    else{
		return "hello";//这里也是错的，应为“hello"是一个临时变量
    }

}
```



**引用返回左值**

函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。这是一个很有用的技巧，它能帮助我们实现链式调用以及在返回的值中继续做修改。

例如：

```cpp
char& get_val(string &str,string::size_type ix)
{
    return str[ix];
}

get_val(s,0)='A';
```



**列表初始化返回值**：

函数可以返回花括号包围的值的列表。（`C++11`）这个列表可以用于初始化

例如：

```cpp
vector<string> porcess（）
{
    if(expetced().empty()){
        return {};
    }else{
		return {"hello","world","xxx"};
    }
}
```



**主函数main的返回值**：

如果结尾没有`return`，编译器将隐式地插入一条返回0的`return`语句。返回0代表执行成功,一般使用-1代表失败。

> 注意在含有return语句的循环后面应该也需要加上一条return语句，否则该程序就是错的。但是大多数编译器无法检测出来这部分错误。
>
> 此外还要注意以下几点：
>
> - 不要返回局部变量对象的引用或者指针
> - 善于使用引用来作为返回对象

### 返回数组指针

一般如下：

```cpp
using arrT=int[10];
arrT* func(int i);
```

一般形式

```cpp
type (*function(参数)）[数组大小]
//例如
int (*func(int i)) [10];
```



**尾置返回类型**：

任何函数的定义都能使用尾置返回，这很使用于返回复杂的数据类型。

语法：在之前补上auto,然后在形参列表后面以一个`->`开始：`auto func(int i) -> int(*)[10]`（`C++11`）

## 函数重载

**重载**：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。

注意：`main`函数不能重载。



**重载和const形参**：

- 一个有顶层const的形参和没有它的函数无法区分，顶层const不能作为区分函数重载的方法。 `Record lookup(Phone* const)`和 `Record lookup(Phone*)`无法区分。
- 相反，是否有某个底层const形参可以区分。 `Record lookup(Account*)`和 `Record lookup(const Account*)`可以区分。

> 什么时候应该重载？
>
> ​		通常，我们认为当一组函数在功能和结构上很相似的时候，我们才去进行重载。最核心的判断准则还是重载之后，是否会帮助我们理解。

**重载和作用域**：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。因此函数的定义统一都放到外层。

## 特殊用途语言特性

### 默认实参

默认参数，是一个很有用的技巧，他能帮函数变量提供默认值。例如：

`string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');`

这里四个都是默认实参，在调用参数的时候，我们可以选择传参数与不传参数。

> **一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。**默认参数的位置很重要，一般来说，我们应该尽可能的将经常默认值的形参放在后面。
>
> 参数顺序：普通参数-》经常需要修改值的默认参数-》不经常修改默认值的默认参数

### 内联（inline）函数

普通函数的缺点：调用函数比求解等价表达式要慢得多，有多余的栈帧开辟释放以及上下文保护的开销。内联函数能够避免这些开销。

- `inline`函数可以避免函数调用的开销，可以让编译器在编译时**内联地展开**该函数。

内联函数适合用于较小，经常使用的函数。

例如：

```cpp
inline const string &
shorterString(const string& s1,const string& s2)
{
	return (s1.size()<s2.size())?s1:s2;
}
```

类似于C语言的宏函数

**`inline`函数最好应该在头文件中实现**

### constexpr函数

指能用于常量表达式的函数，即把返回值的类型设置为常量，需要注意的是，形参和返回值都应该是字面值类型。

- `constexpr int new_sz() {return 42;}`
- **函数的返回类型及所有形参类型都要是字面值类型**。
- `constexpr`函数应该在头文件中定义。

例如：

```cpp
constexpr size_t scale(size_t cnt){return new_sz*cnt}

int arr[scale(2)]//这就意味着，函数的返回值能当作常量处理
```



### 调试帮助（待补全）

`assert`预处理宏（preprocessor macro）：`assert(expr);`

如果

开关调试状态：

`CC -D NDEBUG main.c`可以定义这个变量`NDEBUG`。

```cpp
void print(){
    #ifndef NDEBUG
        cerr << __func__ << "..." << endl;
    #endif
}
```

## 函数匹配

- 重载函数匹配的**三个步骤**：1.候选函数；2.可行函数；3.寻找最佳匹配。
- **候选函数**：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。
- **可行函数**：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。
- **寻找最佳匹配**：基本思想：实参类型和形参类型越接近，它们匹配地越好。

## 函数指针

**函数指针**：是指向函数的指针。

例如：`bool (*pf)(const string &, const string &);` 注：两端的括号不可少，这说明了这是一个指针，指向一个函数，pf=函数名，就可以实现直接对pf的赋值

**函数指针作为形参，能让我们将一个函数，作为参数传入到另一个函数中**：

- 形参中使用函数定义或者函数指针定义效果一样。
- 使用类型别名或者`decltype`。

例如：

```cpp
void useBigger(const string &s1,const string &s2,
			bool (*pf)(const string &,const string &));
```



**返回指向函数的指针**

- 类型别名
- 尾置类型

例如：

```cpp
using F=int(int*,int);

F* func();

using F1=int (*) (int*,int);

F1 func();

auto func()->int (*)(int*,int)
```







