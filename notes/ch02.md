# 第二章 变量和基本类型

任何常用的编程语言都具备一组公共的语法特征，最基本的特征包括：

- 整型、字符型等内置类型
- 变量，用来为对象命名
- 表达式和语句，用于操作上述数据类型的具体值
- if 或 while 等控制结构，有选择地执行一些语句或重复地执行一些语句
- 函数，用于定义可供随时调用的计算单元

数据类型决定了程序中数据和操作的意义，`i=i+j`，对于不同的数据类型来说，有着不一样的含义。大多数编程语言通过两种方式来进一步补充其基本特征：

- 自定义数据类型，实现对语言的扩展
- 将一些有用的功能封装成库函数

## 基本内置类型

### **基本算数类型**：

| 类型          | 含义           | 最小尺寸                       |
| ------------- | -------------- | ------------------------------ |
| `bool`        | 布尔类型       | 8bits                          |
| `char`        | 字符           | 8bits                          |
| `wchar_t`     | 宽字符         | 16bits                         |
| `char16_t`    | Unicode字符    | 16bits                         |
| `char32_t`    | Unicode字符    | 32bits                         |
| `short`       | 短整型         | 16bits                         |
| `int`         | 整型           | 16bits (在32位机器中是32bits)  |
| `long`        | 长整型         | 32bits                         |
| `long long`   | 长整型         | 64bits （是在C++11中新定义的） |
| `float`       | 单精度浮点数   | 6位有效数字                    |
| `double`      | 双精度浮点数   | 10位有效数字                   |
| `long double` | 扩展精度浮点数 | 10位有效数字                   |

其中`char16_t`,`char32_t`,`wchar_t`属于扩展类型。`wchar_t`用于确保可以存放机器的拓展字符中的最大哪一个，`char16_t`,`char32_t`主要用于Unicode编码使用。

对于int，char类型来说，可以添加`signed`和`unsigned`前缀来确定符号位是否使用。

### 如何选择类型

- 1.当明确知晓数值不可能是负数时，选用无符号类型；
- 2.使用`int`执行整数运算。一般`long`的大小和`int`一样，而`short`常常显得太小。除非超过了`int`的范围，选择`long long`。
- 3.算术表达式中不要使用`char`或`bool`。
- 4.浮点运算选用`double`。

### 类型转换

- 非布尔型赋给布尔型，初始值为0则结果为false，否则为true。
- 布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。
- 浮点数赋给整数，直接去除小数部分，如果整数赋给浮点数，小数部分变为0.
- 对于无符号类型，如果赋给它的值太大，那么会进行取模运算，对于有符号类型，超过范围结果无法确定

### 字面值常量

一个形如`42`的值被称作**字面值常量**（literal），每一种字面值常量都对应着一种数据类型



**整型和浮点型字面值**

使用0开头的数字，表示8进制，0x或者0X表示16进制。例如：`024`和`0x14`实际上其值都代表20.

浮点型使用小数或者科学计数法表示，例如：`3.14E0`

**字符和字符串字面值**

使用单引号括起来的一个字符是字符常量，使用“”括起来的是字符串常量，字符串常量本质上是由常量字符构成的数组。编译器会默认在每个字符串常量后面添加`'\0'`来表示字符串的结尾。字符`'A'`和`"A"`并不等价的原因也正在此处，`"A"`还多了一个`'\0'`

可以分行书写字符串

```cpp
std:cout<<"wow, a really, really long string"
          "literal that spans two lines" <<std::endl;
```

**转义字符**

`\`如果后面跟着的八进制字符超过三个，只计算前三个与之构成的

使用转移字符来打印一些特定的内容

**布尔字面值和指针型**

- 布尔字面值。`true`，`false`。
- 指针字面值。`nullptr`

## 变量

**变量**提供一个**具名**的、可供程序操作的存储空间。   数据类型决定变量的空间大小和内存布局，以及一些操作规范。`C++`中**变量**和**对象**一般可以互换使用。

### 变量定义（define）

- **定义形式**：类型说明符（type specifier） + 一个或多个变量名组成的列表。如`int sum = 0, value, units_sold = 0;`
- **初始化**（initialize）：对象在创建时获得了一个特定的值。
  - **初始化不是赋值！**：
  - 初始化 = 创建变量 + 赋予初始值
  - 赋值 = 擦除对象的当前值 + 用新值代替
  - **列表初始化**：
    - 使用花括号`{}`，如`int units_sold{0};`，发生类型转换的时候会发生报错
    - 使用`()`，如`int a(0);`
    - `int a={0};`
    - 还是建议使用=来初始化
  - 默认初始化：定义时没有指定初始值会被默认初始化；**在函数体内部的内置类型变量将不会被初始化，函数体外一般默认初始话为0**。
  - 建议初始化每一个内置类型的变量。

>未初始化变量导致的错误，一般而言很难发现，因此初始化变量是一个很好的习惯，全局变量的话会默认初始化。
>
>幸运的是在函数体内，未初始化变量的值是不确定的，因此没有初始化就使用的话很容易报错。

### 变量的**声明**（declaration） vs **定义**（define）

为了支持分离式编译，`C++`将声明和定义区分开。**声明**使得名字为程序所知。**定义**负责创建与名字关联的实体。

声明的语法：

```cpp
extern int i;
```

**这里仅仅只是实现了变量的声明，不能赋值，如果赋值的话，那就变成了定义。extern也将没有意义。**例如：`extern int i=10;`这就是一个定义。

>变量只能被定义一次，但是可以多次声明。为了在多个文件中实现分文件编译，我们需要使用到声明的技术。具体而言，我们只能在一个定义一个变量，在其他想使用这个变量的文件中，extern声明该变量即可。**仅仅只是声明，不能重复定义**

### 作用域

即变量定义的作用域，使用`{}`来区分变量作用域。作用域之间具有嵌套关系，内层的作用域内能访问到外层的作用域的内容。内层作用域中也可以定义同名变量来覆盖外层作用域中的变量。所有全局变量和函数的作用域为全局作用域，使用`::`来表示。

>**定义变量的时候，最好是用到了在去定义。用到全局变量时，尽量不适用重名的局部变量。**

### 变量命名规范

1. 需体现实际意义
2. 变量名用小写字母
3. 自定义类名用大写字母开头：Sales_item
4. **标识符由多个单词组成，中间须有明确区分**：student_loan或studentLoan，不要用studentloan。这里我选择使用第二种`studentLoan`类型。

## 左值和右值

- **左值**（l-value）**可以**出现在赋值语句的左边或者右边，比如变量；
- **右值**（r-value）**只能**出现在赋值语句的右边，比如常量。

## 复合类型

复合类型是指基于其他类型定义的类型。引用和指针是其中两种最重要的符合类型。

这里普遍性的将声明语句视为：`基本数据类型 声明符`的结构

### 引用

> 一般说的引用是指的左值引用
**引用**：引用是一个对象的别名，引用类型引用（refer to）另外一种类型。通过将声明符写为`&name`的形式来定义引用类型，如`int &refVal = val;`。

>**引用必须声明的时侯进行初始化，`int &val;`这类使用方法是错误的**
>
>引用实质上是对一个已经存在的对象起一个别名，底层由指针实现

引用不能指向一个常量，并且引用的类型应该和被引用的类型一致。

### 指针

指针是指向另一种类型的复合类型。定义指针的方法是将声明符写为`*name`的形式。例如：`int *val`

> int *p;      //**指向int型对象**的指针

是一种 `"指向（point to）"`另外一种类型的复合类型。它存放的是某个对象的**地址**。

需要注意的是，指针的类型与所指向的对象类型必须一致（均为同一类型int、double等）

- 指针的值的四种状态：
  - 1.指向一个对象；
  - 2.指向紧邻对象的下一个位置；
  - 3.空指针；
  - 4.无效指针。

**空指针**

空指针不指向任何对象，因此在使用一个指针的时候需要提前判断是否为空。C++中使用`nullptr`来表示空指针，也可以使用`0`或者`NULL`，建议使用`nullptr`

> 这里同样建议，定义的时候，就初始化指针，如果没有想好定义啥，建议使用`nullptr`或者0来给其初始化。

**`void*`指针**

`void*`指针是一种特殊的指针类型，可以存放任何对象的地址。**但是不能直接使操作void*指针指向的对象**，通常使用其与其他类型的指针作比较，以及作为函数的输入和输出。



**复合类型的声明**

变量的声明包括了一个基本类型和一组声明符。在同一条语句中，虽然基本类型只能有一个，但是声明符可以有多个。例如：`int p,*q,&m=p;`

读懂一个复合类型的声明的一个办法就是从右往左读，例如：

```cpp
int a=10;
int *p=&a;
int *&ref=p;
```

ref为指针变量p的一个引用。但是这里需要注意引用变量不能定义指针指向它。

## const限定符

`const`限定符用于限定变量的值不可以被改变。这样能避免我们在使用的时候，误修改其值。

### 初始化和const
const对象的值不能被修改，因此`const`变量**必须初始化**，若不初始化会报错。

const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern。要想在多个文件中使用const变量共享，定义和声明都加const关键字即可。

多文件导入`extern`一般流程如下

```cpp
//file.h,用于声明函数定义和导入其他数据
extern const int age;
....
void test();
```

```cpp
//file1.cpp，主要是写实现,z注意需要导入头文件
#include "file1.h"
const int age=10;
void test()
{
	....;
}
```

```cpp
//main.cpp
#include "file1.h"
直接使用
```



### const的引用

**reference to const**（对常量的引用）：因为指向的是const对象的引用，因此引用的基本类型也需要使用`const`来修饰，如 `const int ival=1; const int &refVal = ival;`，可以读取但不能修改`refVal`。

**临时量**（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。例如：

```cpp
const double num=10.0;
const int &age=num;
//这个时候就会产生一个临时量用于暂存
const int temp=num;
const int &age=temp;
```

这类行为毫无意义，因此对临时量的引用是非法的

但是对const的引用对象可以引用到一个非const的对象

```cpp
int age=10;
const int &ref=age
```

对于这里而言，它只能限定，不能通过ref来修改age的值，但是age的值，本身是可以变的

### 指针和const

**pointer to const**（指向常量的指针）：指向常量的指针呢个，也必须使用const来修饰。并且不能用于改变其所指对象的值, 如 `const double pi = 3.14; const double *cptr = &pi;`，即通过`*cptr`来修改变量的值是不可取的。

**const pointer**：指针本身是常量，也就是说指针固定指向该对象，（存放在指针中的地址不变，地址所对应的那个对象值可以修改）如 `int i = 0; int *const ptr = &i;`

> 如何区分：
>
> 依旧是从右往左来看，这里const先修饰ptr，那么ptr就是常量，不可修改其值，然后才是一个指针，指向int类型的对象。这里是指针本身的值不可以变。如果修饰的是int,则说明int对象的值不可以变。

### 顶层const

- `顶层const`：指针本身是个常量，例如：`int *const ptr=&num;`,称内层为顶层const。
- `底层const`：指针指向的对象是个常量。例如：`const int age=10;`是外层的const。拷贝时严格要求相同的底层const资格。

### `constexpr`和常量表达式（▲可选）

- 常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。
- `C++11`新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量的表达式。

## 处理类型

### 类型别名

使用类型别名能让程序里的复杂数据类型变得简单明了，方便统一修改与记忆化。

- 传统别名：使用**typedef**来定义类型的同义词。 `typedef double wages;`
- 新标准别名：别名声明（alias declaration）： `using SI = Sales_item;`（C++11）这种方法，使用`using`关键字作为开头，然后后面为`别名=原来的名字`

```c++
// 对于复合类型（指针等）不能代回原式来进行理解
typedef char *pstring;  // pstring是char*的别名
const pstring cstr = 0; // 指向char的常量指针
// 如改写为const char *cstr = 0;不正确，为指向const char的指针

// 辅助理解（可代回后加括号）
// const pstring cstr = 0;代回后const (char *) cstr = 0;这里pstring是一个指针类型，直接修饰cstr,因此这里const是直接修饰cstr的而非修饰char
// const char *cstr = 0;即为(const char *) cstr = 0;
```

### auto类型说明符 c++11

**auto**类型说明符能让编译器**自动推断表达式返回值的类型**

注意事项：

- 一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型&和*)。`auto sz = 0, pi =3.14//错误`
- `int i = 0, &r = i; auto a = r;` 推断`a`的类型是`int`。
- 会忽略`顶层const`。
- `const int ci = 1; const auto f = ci;`推断类型是`int`，如果希望是顶层const需要自己加`const`

### decltype类型指示符

- 从表达式的类型推断出要定义的变量的类型。
- **decltype**：选择并返回操作数的**数据类型**。
- `decltype(f()) sum = x;` 推断`sum`的类型是函数`f`的返回类型。
- 不会忽略`顶层const`。
- 如果对变量加括号（即`decltype((variable))`这种形式），编译器会将其认为是一个表达式，如int i-->(i),则decltype((i))得到结果为int&引用。
- 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&。
- `C++11`

## 自定义数据结构

### struct

> 尽量不要吧类定义和对象定义放在一起。
>
> 如`struct Student{} xiaoming,xiaofang;`这里需要注意有分号
>
> 而是采用这种形式分离式的定义方法
>
> `struct Student{};`
>
> `Student accum,trans,*salesptr;`
- 类可以以关键字`struct`开始，紧跟类名和类体。
- 类数据成员：类体定义类的成员。
- `C++11`：可以为类数据成员提供一个**类内初始值**（in-class initializer），没有初始值的成员将会被默认初始化。

### 编写自己的头文件

一般而言，类并不定义在函数中，而是实现在函数外。这时候，我们一般采用在头文件来定义类的一个编程方式，并且通常性的将头文件的名字与类名相同。

头文件通常包含哪些只能被定义一次的实体：类、`const`和`constexpr`变量。

我们在定义头文件的时候，需要包含一些其他的头文件，比如`iostream`，然而在实现对类的操作的文件中，我们还是需要引入这些头文件。这就导致了多次引用的问题，为了确保头文件能多次包含，我们引入了预处理器的技术来帮我们。

预处理器概述：

- **预处理器**（preprocessor）：确保头文件多次包含仍能安全工作。
- 当预处理器看到`#include`标记时，会用指定的头文件内容代替`#include`
- **头文件保护符**（header guard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。
  - `#ifdef`已定义时为真
  - `#inndef`未定义时为真。当第一次处理头文件的时候，还没有定义，此时为真，因此顺着执行，直到endif,过程中就会定义了SALES_DATA_H。然后,如果还想引用该头文件的时候，这个时候，由于SALES_DATA_H已经存在，因此为假，直接跳转到endif,就避免了多次包含的问题。
  - 头文件保护符的名称需要唯一，且保持全部大写。养成良好习惯，不论是否该头文件被包含，要加保护符。

```c++
#ifndef SALES_DATA_H  //SALES_DATA_H未定义时为真
#define SALES_DATA_H
strct Sale_data{
    ...
}
#endif
```