# 第三章 字符串、向量和数组

除了内置的数据类型之外，C++语言还定义了一个内容丰富的抽象数据类型库（STL）。本章主要介绍向量，字符串以及数组。

## using声明
当我们使用库中的函数的时候，需要使用命名空间（作用域namespace）加以明确函数的准确来源，避免函数名重复带来的问题。但是这样每次都需要加入作用域，会给写代码带来很大的负担。使用using声明能让我们更轻松的使用到命名空间中的成员。

格式：

```cpp
using namespace::name;
```

有了using声明，我们就可以在空间中之间使用命名空间的名字，例如 `using std::cin`表示使用命名空间`std`中的名字`cin`。之后在后面的程序中，直接写`cin`即可。

> 头文件中不应该包含`using`声明。这样使用了该头文件的源码也会使用这个声明，会带来风险。

## string
- 标准库类型`string`表示可变长的字符序列。
- `#include <string>`，然后 `using std::string;`
- **string对象**：注意，不同于字符串字面值。
  
### 定义和初始化string对象

初始化`string`对象的方式：

| 方式 | 解释 |
| -- | -- |
| `string s1` | 默认初始化，`s1`是个空字符串 |
| `string s2(s1)` | `s2`是`s1`的副本 |
| `string s2 = s1` | 等价于`s2(s1)`，`s2`是`s1`的副本 |
| `string s3("value")` | `s3`是字面值“value”的副本，除了字面值最后的那个空字符外 |
| `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本 |
| `string s4(n, 'c')` | 把`s4`初始化为由连续`n`个字符`c`组成的串 |

- 拷贝初始化（copy initialization）：使用等号`=`将一个已有的对象拷贝到正在创建的对象。
- 直接初始化（direct initialization）：通过括号给对象赋值。
- 两者并无很大的区别，建议使用直接初始化

### string对象上的操作

`string`的操作：

| 操作 | 解释 |
|-----|-----|
| `os << s` | 将`s`写到输出流`os`当中，返回`os` |
| `is >> s` | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is` |
| `getline(is, s)` | 从`is`中读取一行赋给`s`，返回`is` |
| `s.empty()` | `s`为空返回`true`，否则返回`false` |
| `s.size()` | 返回`s`中字符的个数，不包括`'\0'` |
| `s[n]` | 返回`s`中第`n`个字符的引用，位置`n`从0计起 |
| `s1+s2` | 返回`s1`和`s2`连接后的结果 |
| `s1=s2` | 用`s2`的副本代替`s1`中原来的字符 |
| `s1==s2` | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `s1!=s2` | 同上 |
| `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较） |

在使用标准输入读取字符串的时候，会以空格作为字符串的分界线，从第一个非空格认为开始读取字符串，遇到第一个空格的时候，认为读取结束，直到遇到下一个非空格开始下一个字符串的读写。按下回车结束输入过程。

例如：

```cpp
void read()
{
	string s1;
	while (cin >> s1) {
		cout << s1 << endl;
	}
}
```

> 注意这里结束的标志是文件结束符，对于window来说是`ctrl+z`.下面的getline也是

如果想要保留空格，那么我们需要使用函数`getline`，一次读取一整行。换行符每次的输入以回车为结束标志，如果一开始使用回车，那么将得到一个空串。注意输入结果是不包含回车换行符的。可以借助`s.empty()`来辅助判断，是否输入为空（为空的话结果为`true`）。

```cpp
void testGetline()
{
	string line;
	while (getline(cin, line)) {
		if (line.empty()) {
			break;
		}
		cout << line<<endl;
	}
}
```

`s.size()`返回的时`string::size_type`类型，记住是一个**无符号**类型的值，不要和`int`混用，尤其是负数对比，这样会先把负数换为无符号整数来比较。

**字符串运算符**

`==`,`!=`使用字典顺序来依次比较。如果一个是宁一个的前缀，那么前缀更小。

`+`:  ` s1+s2`使用时，保证至少一侧是string类型。`string s1 = "hello" + "world" // 错误，两侧均为字符串字面值`。注意与Java区别，Java的能直接加上任何数据类型。这里只能加上字符串常量和字符常量。

注意：

**字符串字面值和string是不同的类型。**



### 处理string对象中的字符

> c++标准库中除了C++的内容之外，还兼容了C语言的标准库。C语言的标准库以name.h的形式存在，C++的对应的为cname的形式。
>
> 以cname的标准库是属于命令空间std的，但是name.h的头文件则不是，**因此一般而言，我们选择使用cname形式的标准库**

| 函数 | 解释 |
|-----|-----|
| `isalnum(c)` | 当`c`是字母或数字时为真 |
| `isalpha(c)` | 当`c`是字母时为真 |
| `iscntrl(c)` | 当`c`是控制字符时为真 |
| `isdigit(c)` | 当`c`是数字时为真 |
| `isgraph(c)` | 当`c`不是空格但可以打印时为真 |
| `islower(c)` | 当`c`是小写字母时为真 |
| `isprint(c)` | 当`c`是可打印字符时为真 |
| `ispunct(c)` | 当`c`是标点符号时为真 |
| `isspace(c)` | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
| `isupper(c)` | 当`c`是大写字母时为真 |
| `isxdigit(c)` | 当`c`是十六进制数字时为真 |
| `tolower(c)` | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c` |
| `toupper(c)` | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c` |

遍历字符串，可以使用C++11的新语法

```
for(declaration:expression)
	statement
```

其中，declaration是定义一个变量（通常使用`auto`来帮我们自动判断），改变了用于访问基础序列中的基本元素。expression部分为一个对象，表示一个序列。

遍历字符串：使用**范围for**（range for）语句： `for (auto c: str)`，或者 `for (auto &c: str)`**使用引用直接改变字符串中的字符**。 （C++11）

```cpp
void each()
{
	string str("12345678");
	//不使用引用
	for (auto c : str) {
		c += 1;
	}
	cout << str << endl;
	for (auto& c : str) {
		c += 1;
	}
	cout << str << endl;
}
```



也可以使用下标访问`str[x]`,[]输入参数为`string::size_type`类型，给出`int`整型也会自动转化为该类型。**下标的返回值实际上是一个引用，因此能修改其值**

## vector
vector是一个**容器**，也是一个类模板；

`#include <vector>` 然后 `using std::vector;`

容器：包含其他对象。

类模板：本身不是类，但可以**实例化instantiation**出一个类。在使用类模板中，我们需要提供一些额外的信息，来指明类需要实例化成什么样。提供的信息往往是在模板后面使用一堆尖括号，并在括号内提供相应的信息。 `vector`是一个模板， `vector<int>`是一个类型。

### 定义和初始化vector对象

初始化`vector`对象的方法

| 方法 | 解释 |
|-----|-----|
| `vector<T> v1` | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)` | `v2`中包含有`v1`所有元素的副本 |
| `vector<T> v2 = v1` | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本 |
| `vector<T> v3(n, val)` | `v3`包含了n个重复的元素，每个元素的值都是`val` |
| `vector<T> v4(n)` | `v4`包含了n个重复地执行了值初始化的对象，默认为0 |
| `vector<T> v5{a, b, c...}` | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值 |
| `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}` |

列表初始化： `vector<string> v{"a", "an", "the"};` （C++11）

> 一般而言，实际上更建议第一种初始化方法，事实上它体现了vector的可变长性，当确定了长度的话更建议使用数组。
>
> （）里的值，是用于说明容器的初始数量的
>
> {}里的，是用于初始化的。

### 向vector对象中添加元素

`v.push_back(e)` 在尾部增加元素。

### 其他vector操作

`vector`支持的操作：

| 操作 | 解释 |
|-----|-----|
| `v.emtpy()` | 如果`v`不含有任何元素，返回真；否则返回假 |
| `v.size()` | 返回`v`中元素的个数，下标取值范围为[0,size()-1] |
| `v.push_back(t)` | 向`v`的尾端添加一个值为`t`的元素 |
| `v[n]` | 返回`v`中第`n`个位置上元素的**引用** |
| `v1 = v2` | 用`v2`中的元素拷贝替换`v1`中的元素  |
| `v1 = {a,b,c...}` | 用列表中元素的拷贝替换`v1`中的元素 |
| `v1 == v2` | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| `v1 != v2` | 同上 |
| `<`,`<=`,`>`, `>=` | 以字典顺序进行比较 |

- 范围`for`语句内不应该改变其遍历序列的大小。
- `vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。

> 注意：下标溢出，在编写代码的时候，并不会报错。需要编译的时候才会显现出来。这类错误为buffer overflow。一个好的解决办法就是每次使用下标的时候，都需要注意检查是否会出现溢出的情况。

## 迭代器iterator

- 所有标准库容器都可以使用迭代器，但是只有一部分支持下标访问
- 类似于指针类型，迭代器也提供了对对象的间接访问。

### 使用迭代器

迭代器类型：

```
容器类型::iterator iter;

//只读迭代器
容器类型::const_iterator iter;
```

例如`vector<int>::iterator iter`。

比较难写，建议直接写`auto`.

- `auto b = v.begin();`返回指向第一个元素的迭代器。
- `auto e = v.end();`返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。



begin和end

- 如果容器为空， `begin()`和 `end()`返回的是同一个迭代器，都是尾后迭代器。
- 可以使用cbegin和cend来让迭代器的类型默认为只读的

```cpp
auto it=v.begin();//不是只读
auto it=v.cbegin();//为只读
```

> 注意但凡使用了迭代器的循环体，都不要在迭代器所属的容器中添加元素

结合解引用和成员访问符

- 使用解引用符`*`访问迭代器指向的元素。
- 使用`(*it).empty()`类似的方法来调用方法，当然等效于`it->empty()`,更推荐使用后者。

- **箭头运算符**： 解引用 + 成员访问，`it->mem`等价于 `(*it).mem`

标准容器迭代器的运算符:

| 运算符 | 解释 |
|-----|-----|
| `*iter` | 返回迭代器`iter`所指向的**元素的引用** |
| `iter->mem` | 等价于`(*iter).mem` |
| `++iter` | 令`iter`指示容器中的下一个元素 |
| `--iter` | 令`iter`指示容器中的上一个元素 |
| `iter1 == iter2` | 判断两个迭代器是否相等 |

### 迭代器运算

`vector`和`string`迭代器支持的运算：

| 运算符 | 解释 |
|-----|-----|
| `iter + n` | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter - n` | 迭代器减去一个整数仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter1 += n` | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1` |
| `iter1 -= n` | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1` |
| `iter1 - iter2` | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 |
| `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，如果某迭代器 |

例子:使用迭代器实现二分搜索

```cpp
template <typename T,typename B>
B binarySearch(T text,B data)
{
	auto begin = text.begin();
	auto end = text.end();
	auto mid = begin + (end - begin) / 2;
	while (mid != end && *mid != data) {
		if (data < *mid) {
			end = mid;
		}
		else {
			begin = mid;
		}
		mid = begin + (end - begin) / 2;
	}
	return *mid;
}
```



## 数组

- 相当于vector的低级版，**长度固定**。

### 定义和初始化内置数组

- 初始化：`char input_buffer[buffer_size];`，长度必须是const表达式，或者数字常量，或者不写，让编译器自己推断。
- 数组不允许直接赋值给另一个数组。
- **函数内部数组的默认值是不确定的（整形），函数外部，数组的默认值为0**



### 声明

一般而言来说，我们理解声明需要从右向左来理解，但是对于数组来说我们一般采用从内向外阅读的方式，能更好的理解。

主要区别一下几个：

```
int *arr[10];
//首先arr,是一个数组，这个数组有10个元素，元素的类型为整形指针
int (*arr)[10]
//arr是一个指针，然后指向的对象是一个10个元素的数组
int *(&arr)[10]
//arr是一个引用，应用的对象是一个数组，数组的元素类型为int型的指针
```



### 访问数组元素

- 数组下标的类型：`size_t`（定义于`stddef.h`中） 。
- 字符数组的特殊性：结尾处有一个空字符，如 `char a[] = "hello";` 。
- 用数组初始化 `vector`： `int a[] = {1,2,3,4,5}; vector<int> v(begin(a), end(a));` 。

建议使用

```
for(auto c:arr){

}
```

方式来遍历

### 数组和指针

使用数组名字时，编译器一般会把它自动地转换成一个指向数组首元素的指针。

指针也是一种特殊的迭代器，能使各种算数操作。

**首尾指针**

```cpp
int arr[10] = {0,2,3,4,5,6,7,8,9,10};
	int* start = begin(arr);
	int* last = end(arr);
	while (start != last) {
		cout << *start++ << endl;
	}
```

使用库函数`begin`和`end`来找到首尾指针

**指针运算**

可以对指针进行加法，减法，自增等运算

常见使用场景如下：

加法

```c
int arr[10] = {0,2,3,4,5,6,7,8,9,10};
int* p=arr+4;
int num=p[-2];
```

这里`p[-2]`本质上是`*(p-2)==*(arr+4-2)`

求长度

```cpp
auto length=begin(arr)-end(arr);
```

指针之间的比较大小

- 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。 
- **指针访问数组**：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。

## 多维数组

多维数组的定义应当是数组的数组

- **多维数组的初始化**： `int ia[3][4] = {{0,1,2,3}, ...，{4，5，6，7}}`。
- **使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型，这样能避免对象被引用为指针，这样就会导致下一层无法使用，从而报错。**

```cpp
for(auto &row:arr){
    for(auto &col:row){
	
    }
}
```

否则第二层就不是可迭代的对象了



**使用别名来简化**

```cpp
using int_array=int[4];
typedef int int_array[4];
```

这两种方法等价，但推荐使用第一种



指针vs引用

- 引用总是指向某个对象，定义引用时没有初始化是错的。
- 给引用赋值，修改的是该引用所关联的对象的值，而不是让引用和另一个对象相关联。

注意数组和指针之间的关系

```cpp
int arr[3][4] = { {1,2},{3},{4,4,5,6} };
	int(*p)[4] = arr;
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 4; j++) {
			cout << *(*(p + i) + j)<<" ";
		}
		cout << endl;
	}
```





## 动态数组

- 使用 `new`和 `delete`表达和c中`malloc`和`free`类似的功能，即在堆（自由存储区）中分配存储空间。
- 定义： `int *pia = new int[10];` 10可以被一个变量替代。
- 释放： `delete [] pia;`，注意不要忘记`[]`。

